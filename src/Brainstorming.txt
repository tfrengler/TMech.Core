public sealed class FetchContext
{
  public static FetchContext Create(ISearchContext context)
  public static FetchContext Create(ISearchContext context, TimeSpan timeout)
  internal FetchContext(ISearchContext context, TimeSpan timeout)

  public TimeSpan DefaultTimeout { get; } = TimeSpan.FromSeconds(5.0d);
  public int PollingInterval { get; set; } = 300;
  public TimeSpan Timeout { get; }
  public ISearchContext SearchContext { get; private set; }
  public Element? SpawnedBy { get; init; }

  public Element Fetch(By locator)
  public Element[] FetchAll(By locator, uint threshold = 1)

  public bool TryFetch(By locator, [NotNullWhen(true)] out Element? element, [NotNullWhen(false)] out Exception? error)
  public bool TryFetchAll(By locator, out Element[] elements, uint threshold = 1)

  public bool Exists(By locator, out Element? element)
  public int AmountOf(By locator)

  public ConditionalFetchContext When(By locator)
}

public sealed class ConditionalFetchContext
{
  internal ElementWaiter(ElementFactory factory, By locator)
  FetchContext WrappedFactory { get; }
  By Locator { get; }
  TimeSpan Timeout { get; }

  ConditionalFetchContext IsDisplayed()
  ConditionalFetchContext IsNotDisplayed()
  ConditionalFetchContext IsNotEnabled()
  ConditionalFetchContext IsEnabled()
  ConditionalFetchContext IsSelected()
  ConditionalFetchContext IsNotSelected()
  ConditionalFetchContext AttributeIsEqualTo(string attributeName, string attributeValue)
  ConditionalFetchContext AttributeStartsWith(string attributeName, string attributeValue)
  ConditionalFetchContext AttributeEndsWith(string attributeName, string attributeValue)
  ConditionalFetchContext AttributeContains(string attributeName, string attributeValue)
  ConditionalFetchContext AttributeHasContent(string attributeName)
  ConditionalFetchContext ContentIsEqualTo(string text)
  ConditionalFetchContext ContentIsNotEqualTo(string text)
  ConditionalFetchContext ContentStartsWith(string text)
  ConditionalFetchContext ContentEndsWith(string text)
  ConditionalFetchContext ContentContains(string text)
  ConditionalFetchContext HasContent()
  ConditionalFetchContext IsClickable()
  ConditionalFetchContext DoesNotExist()

  Element? Fetch()
}

public class Element : FetchContext
{
  WebElement UnWrap()
  WebElement WrappedElement { get; private set; }
  ElementFactory ProducedBy { get; }
  By RelatedLocator { get; }
  ISearchContext RelatedContext { get; private set; }
  bool LocatedAsMultiple { get; }
  int RetryAttempts { get; private set; } = 50;
  Guid Identifier { get; }

  public Element Reacquire(bool throwOnError)
  public Element WithRetryCount(int attempts)
  public Element Click()
  public Element ClickUntil(Func<Element, bool> predicate)
  public Element ScrollIntoView()
  public Element SendKeystrokes(string keysequence)
  public Element Clear(bool usingKeystrokes = false)

  public string GetFormControlType()
  public string GetInnerHTML()
  public string GetId()
  public string GetTagName()
  public string GetInnerText(bool removeAdditionalWhitespace = true)
  public bool IsDisplayed()

  public FetchContext Within()
}

public sealed class FormControlAttributes()
{
  Dictionary<string, string> GetDataSet()

  string GetAccept()
  string GetFormaction()
  string GetFormenctype()
  string GetFormmethod()
  string GetName()
  string GetPattern()
  string GetPlaceholder()
  string GetSource()
  string GetType()
  string GetValue()
  string GetList()

  int GetStep()
  int GetSize()
  int GetWidth()
  int GetHeight()
  int GetMax()
  int GetMaxlength()
  int GetMin()
  int GetMinlength()

  bool IsChecked()
  bool IsDisabled()
  bool IsReadonly()
  bool IsRequired()
  bool IsMultiple()

  Dictionary<string, string> GetAll()
  string Get(string name)
}

public class FormControlElement : Element
{
  public FormControlElement WithRobustSelection()
  public void SetValue(string input, bool clear = true)
  public void UploadFile(string input)
  public string GetValue()
  public string GetName()
  public string GetInputType()
  public int? GetMin()
  public int? GetMax()
  public int? GetMaxLength()
  public int? GetMinLength()
  public string GetSource()
  public int? GetStep()
  public bool IsRequired()
  public bool IsReadOnly()
  public bool IsEnabled()
}

public sealed class NumericElement : FormControlElement
{
  public new IntegerElement WithRobustSelection()
  public int? GetValueAsInteger()
  public int? GetValueAsFloat(NumberFormatInfo? format = null)
  public int? GetValueAsDouble(NumberFormatInfo? format = null)
  public void SetNumeric(int number)
  public void SetNumeric(float number)
  public void SetNumeric(double number)
}

public sealed class DropdownElement : FormControlElement
{
  public new DropdownElement WithRobustSelection()
  public bool IsMultiple()
  public void SetDropdownItemByValue(string value)
  public void UnsetDropdownItemByText(string text)
  public void UnsetDropdownItemByValue(string value)
  public void SetDropdownItemByText(string text, bool partialMatch = false)
  public FormControlElement GetSelectedOption()
  public IList<FormControlElement> GetSelectedOptions()
  public IList<FormControlElement> GetAvailableOptions()
}

public sealed class DateElement : FormControlElement
{
  public new DateElement WithRobustSelection()
  public const string ValueAttributeFormat = "yyyy-MM-dd";
  public const string ChromiumFormat = "ddMMyyyy";
  public const string FirefoxFormat = "MMddyyyy";
  public DateOnly GetDate()
  public DateOnly GetDate(string format = ValueAttributeFormat)
  public void SetDateByKeystroke(DateTime input, string format)
  public void SetDateByKeystroke(DateOnly input, string format)
  public void SetDate(DateTime input)
  public void SetDate(DateOnly input)
}

public sealed class BooleanElement : FormControlElement
{
  public new BooleanElement WithRobustSelection()
  public void Select()
  public void Select(bool desiredState)
  public void Deselect()
  public bool IsSelected()
}